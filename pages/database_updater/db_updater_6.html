<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>D&D Campaign Manager 3.3 - Advanced</title>
		<script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
		<link href="https://cdn.jsdelivr.net/npm/tom-select@2.2.2/dist/css/tom-select.css" rel="stylesheet" />
		<script src="https://cdn.jsdelivr.net/npm/tom-select@2.2.2/dist/js/tom-select.complete.min.js"></script>

		<style>
			:root {
				--bg-dark: #1a1b26;
				--bg-card: #24283b;
				--bg-input: #16161e;
				--accent: #7aa2f7;
				--accent-hover: #5d85d8;
				--text-main: #c0caf5;
				--text-muted: #565f89;
				--border: #414868;
				--success: #9ece6a;
				--danger: #f7768e;
				--warning: #e0af68;
			}

			* {
				box-sizing: border-box;
				margin: 0;
				padding: 0;
			}
			body {
				font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
				background: var(--bg-dark);
				color: var(--text-main);
				padding: 20px;
				line-height: 1.6;
			}

			/* Layout */
			.container {
				max-width: 1800px;
				margin: 0 auto;
			}
			.grid {
				display: grid;
				gap: 20px;
			}
			.grid-main {
				grid-template-columns: 250px 1fr;
			}
			/* Changed to fit Cross Ref panel better */
			.grid-content {
				grid-template-columns: 350px 1fr;
			}
			.editor-column {
				display: flex;
				flex-direction: column;
				gap: 20px;
			}

			@media (max-width: 1000px) {
				.grid-main {
					grid-template-columns: 1fr;
				}
				.grid-content {
					grid-template-columns: 1fr;
				}
			}

			/* UI Components */
			.card {
				background: var(--bg-card);
				border: 1px solid var(--border);
				border-radius: 8px;
				padding: 20px;
			}
			.btn {
				background: var(--accent);
				color: #1a1b26;
				border: none;
				padding: 8px 16px;
				border-radius: 6px;
				cursor: pointer;
				font-weight: 600;
				transition: 0.2s;
				display: inline-flex;
				align-items: center;
				justify-content: center;
				gap: 5px;
			}
			.btn:hover {
				background: var(--accent-hover);
			}
			.btn-danger {
				background: var(--danger);
				color: white;
			}
			.btn-success {
				background: var(--success);
				color: #1a1b26;
			}
			.btn-sm {
				padding: 4px 8px;
				font-size: 0.85em;
			}
			.btn-outline {
				background: transparent;
				border: 1px solid var(--border);
				color: var(--text-main);
			}
			.btn-active {
				background: var(--accent);
				color: var(--bg-dark);
				border-color: var(--accent);
			}
			.btn-icon {
				padding: 4px 10px;
				font-size: 1.2em;
				line-height: 1;
			}

			input,
			select,
			textarea {
				width: 100%;
				background: var(--bg-input);
				border: 1px solid var(--border);
				color: var(--text-main);
				padding: 10px;
				border-radius: 6px;
				outline: none;
				font-family: inherit;
				resize: vertical;
			}
			input:focus,
			select:focus,
			textarea:focus {
				border-color: var(--accent);
			}

			/* Tom Select Dark Mode Overrides */
			.ts-control {
				background-color: var(--bg-input) !important;
				border-color: var(--border) !important;
				color: var(--text-main) !important;
				border-radius: 6px;
				padding: 10px;
			}
			.ts-dropdown {
				background-color: var(--bg-card) !important;
				border-color: var(--border) !important;
				color: var(--text-main) !important;
			}
			.ts-dropdown .option {
				color: var(--text-main);
			}
			.ts-dropdown .active {
				background-color: var(--accent) !important;
				color: var(--bg-dark) !important;
			}
			.ts-control input {
				color: var(--text-main) !important;
			}
			.ts-wrapper.single .ts-control:after {
				border-color: var(--text-muted) transparent transparent transparent !important;
			}

			.ts-wrapper {
				width: 100%;
			}

			label {
				display: block;
				margin-bottom: 5px;
				font-size: 0.85em;
				color: var(--text-muted);
				font-weight: 600;
				text-transform: uppercase;
				letter-spacing: 0.5px;
			}

			/* Navigation */
			.nav-section {
				margin-bottom: 20px;
			}
			.nav-title {
				font-size: 0.8em;
				text-transform: uppercase;
				color: var(--text-muted);
				margin-bottom: 8px;
				font-weight: bold;
				letter-spacing: 1px;
			}
			.nav-item {
				display: block;
				width: 100%;
				text-align: left;
				padding: 8px 12px;
				background: transparent;
				border: none;
				color: var(--text-main);
				cursor: pointer;
				border-radius: 4px;
				transition: 0.2s;
				margin-bottom: 2px;
			}
			.nav-item:hover {
				background: rgba(255, 255, 255, 0.05);
			}
			.nav-item.active {
				background: var(--accent);
				color: var(--bg-dark);
				font-weight: bold;
			}

			/* Tables */
			.table-wrapper {
				overflow-x: auto;
				border-radius: 6px;
				border: 1px solid var(--border);
			}
			table {
				width: 100%;
				border-collapse: collapse;
				font-size: 0.9em;
			}
			th,
			td {
				padding: 10px 15px;
				text-align: left;
				border-bottom: 1px solid var(--border);
				white-space: nowrap;
			}
			th {
				background: rgba(0, 0, 0, 0.2);
				color: var(--text-muted);
				font-weight: 600;
				position: sticky;
				top: 0;
				cursor: pointer;
				user-select: none;
			}
			th:hover {
				color: var(--text-main);
				background: rgba(255, 255, 255, 0.05);
			}
			tr:last-child td {
				border-bottom: none;
			}
			tr:hover {
				background: rgba(255, 255, 255, 0.02);
			}

			/* Filter Panel */
			.filter-panel {
				background: rgba(0, 0, 0, 0.2);
				border-bottom: 1px solid var(--border);
				padding: 15px;
				display: grid;
				grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
				gap: 10px;
				margin-bottom: 10px;
			}
			.filter-item label {
				font-size: 0.75em;
				margin-bottom: 2px;
			}
			.filter-item input,
			.filter-item select {
				padding: 6px;
				font-size: 0.9em;
			}

			/* Cross Reference Panel */
			.ref-category {
				margin-bottom: 15px;
			}
			.ref-header {
				font-size: 0.8em;
				color: var(--warning);
				font-weight: bold;
				text-transform: uppercase;
				margin-bottom: 5px;
				border-bottom: 1px solid var(--border);
				padding-bottom: 2px;
			}
			.ref-tag {
				display: block;
				padding: 6px 10px;
				background: rgba(255, 255, 255, 0.03);
				border: 1px solid var(--border);
				border-radius: 4px;
				margin-bottom: 5px;
				font-size: 0.85em;
				cursor: pointer;
				transition: 0.2s;
			}
			.ref-tag:hover {
				border-color: var(--accent);
				background: rgba(255, 255, 255, 0.05);
			}
			.ref-tag .ref-id {
				color: var(--text-muted);
				font-size: 0.8em;
				margin-right: 5px;
			}

			/* Utilities */
			.hidden {
				display: none !important;
			}
			.flex-between {
				display: flex;
				justify-content: space-between;
				align-items: center;
			}
			.flex-gap {
				display: flex;
				gap: 10px;
			}
			.form-group {
				margin-bottom: 15px;
			}
			.input-group {
				display: flex;
				gap: 8px;
			}

			/* JSON Toolbar */
			.json-toolbar {
				display: flex;
				justify-content: flex-end;
				margin-bottom: 5px;
			}
			.code-input {
				font-family: 'Courier New', monospace;
				font-size: 0.85em;
			}

			/* Modal */
			.modal-overlay {
				position: fixed;
				top: 0;
				left: 0;
				right: 0;
				bottom: 0;
				background: rgba(0, 0, 0, 0.7);
				display: flex;
				align-items: center;
				justify-content: center;
				z-index: 2000;
				backdrop-filter: blur(2px);
			}
			.modal-content {
				background: var(--bg-card);
				width: 500px;
				max-width: 90%;
				max-height: 90vh;
				overflow-y: auto;
				padding: 25px;
				border-radius: 8px;
				border: 1px solid var(--border);
				box-shadow: 0 20px 50px rgba(0, 0, 0, 0.5);
			}

			/* Toast */
			.toast {
				position: fixed;
				bottom: 20px;
				right: 20px;
				padding: 15px 25px;
				border-radius: 8px;
				color: white;
				font-weight: bold;
				transform: translateY(100px);
				transition: 0.3s;
				z-index: 3000;
				box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
			}
			.toast.show {
				transform: translateY(0);
			}
			.toast.success {
				background: var(--success);
				color: #1a1b26;
			}
			.toast.error {
				background: var(--danger);
			}
			.tag {
				display: inline-block;
				padding: 2px 6px;
				border-radius: 4px;
				font-size: 0.8em;
				background: var(--bg-input);
				border: 1px solid var(--border);
			}
		</style>
	</head>
	<body>
		<div class="container">
			<div class="card flex-between" style="margin-bottom: 20px">
				<div>
					<h1 style="font-size: 1.5em">üêâ DM Console 3.3</h1>
					<div id="activeCampaignDisplay" style="color: var(--text-muted); font-size: 0.9em">No Campaign Selected</div>
				</div>
				<div style="display: flex; gap: 10px">
					<select id="campaignSelector" style="width: 200px" onchange="handleCampaignSwitch()"></select>
					<button onclick="toggleConfig()" class="btn btn-outline btn-sm">‚öôÔ∏è DB Config</button>
				</div>
			</div>

			<div id="configSection" class="card hidden" style="margin-bottom: 20px; border-color: var(--warning)">
				<h3 style="color: var(--warning); margin-bottom: 15px">Database Connection</h3>
				<div class="form-group">
					<label>Supabase URL</label>
					<input
						type="text"
						id="sbUrl"
						placeholder="https://xxx.supabase.co"
						value="https://yffukfulnggfhlgoyowg.supabase.co" />
				</div>
				<div class="form-group">
					<label>Supabase Key</label>
					<input
						type="password"
						id="sbKey"
						placeholder="public-anon-key"
						value="sb_publishable_AX2-qMjR0Jigxgcc3UET1g_YYBTaBUz" />
				</div>
				<button onclick="initApp()" class="btn">Connect & Load</button>
			</div>

			<div id="appContent" class="grid grid-main hidden">
				<div class="card" style="height: fit-content; padding: 15px">
					<div id="navContainer"></div>
				</div>

				<div class="grid grid-content">
					<div class="editor-column">
						<div class="card">
							<div
								class="flex-between"
								style="margin-bottom: 15px; padding-bottom: 10px; border-bottom: 1px solid var(--border)">
								<h3 id="formTitle">Editor</h3>
								<button onclick="resetForm()" class="btn btn-sm btn-outline">New Item</button>
							</div>
							<form id="dynamicForm" onsubmit="handleFormSubmit(event)"></form>
						</div>

						<div id="crossRefContainer" class="card hidden">
							<div class="flex-between" style="margin-bottom: 10px">
								<h3 style="font-size: 1em">üîó Linked Items</h3>
								<span id="refCount" style="font-size: 0.8em; color: var(--text-muted)">0 refs</span>
							</div>
							<div id="crossRefList" style="max-height: 300px; overflow-y: auto"></div>
						</div>
					</div>

					<div class="card" style="overflow: hidden; display: flex; flex-direction: column; height: 85vh">
						<div class="flex-between" style="margin-bottom: 15px">
							<div class="flex-gap" style="align-items: center">
								<h3 id="tableTitle">Data</h3>
								<span id="tableStatus" class="tag hidden"></span>
							</div>
							<div class="flex-gap">
								<button id="btnToggleFilters" onclick="toggleFilterPanel()" class="btn btn-sm btn-outline">
									üîç Filters
								</button>
								<button onclick="refreshTable()" class="btn btn-sm btn-outline">‚Üª</button>
							</div>
						</div>

						<div id="filterPanelContainer" class="filter-panel hidden"></div>

						<div class="table-wrapper" id="dataTable" style="flex-grow: 1; overflow-y: auto"></div>
					</div>
				</div>
			</div>
		</div>

		<div id="quickAddModal" class="modal-overlay hidden">
			<div class="modal-content">
				<div class="flex-between" style="margin-bottom: 15px">
					<h3 id="modalTitle">Quick Add</h3>
					<button onclick="closeQuickAdd()" class="btn btn-sm btn-outline">‚úï</button>
				</div>
				<form id="quickAddForm" onsubmit="handleQuickAddSubmit(event)"></form>
			</div>
		</div>

		<div id="toast" class="toast">Message</div>

		<script>
			// ==========================================
			// 1. CONFIG
			// ==========================================
			const NO_CAMPAIGN_ID_TABLES = [
				'campaigns',
				'character_sessions',
				'npc_factions',
				'npc_items',
				'npc_locations',
				'npc_relationships',
				'location_connections',
				'location_features',
				'location_threats',
				'quest_locations',
				'quest_npcs',
				'quest_objectives',
				'encounter_initiative',
				'session_events',
				'encounter_rounds',
				'encounter_actions',
			];

			const SCHEMAS = {
				// --- CAMPAIGN ---
				campaigns: {
					category: 'Campaign',
					label: 'Campaigns',
					fields: [
						{
							key: 'campaign_id',
							label: 'ID (Int)',
							type: 'number',
							required: true,
						},
						{ key: 'name', label: 'Name', type: 'text', required: true },
						{ key: 'metadata', label: 'Metadata', type: 'json' },
						{ key: 'styling', label: 'Styling', type: 'json' },
					],
					listFields: ['campaign_id', 'name'],
				},
				sessions: {
					category: 'Campaign',
					label: 'Sessions',
					fields: [
						{
							key: 'session_number',
							label: 'Session #',
							type: 'number',
							required: true,
						},
						{ key: 'title', label: 'Title', type: 'text', required: true },
						{
							key: 'session_date',
							label: 'Date',
							type: 'date',
							required: true,
						},
						{ key: 'summary', label: 'Summary', type: 'textarea' },
						{ key: 'narrative', label: 'Narrative', type: 'textarea' },
					],
					listFields: ['session_number', 'title', 'session_date'],
				},

				// --- WORLD ---
				locations: {
					category: 'World',
					label: 'Locations',
					fields: [
						{ key: 'name', label: 'Name', type: 'text', required: true },
						{
							key: 'type',
							label: 'Type',
							type: 'select',
							options: [
								'city',
								'town',
								'village',
								'dungeon',
								'wilderness',
								'plane',
								'region',
								'landmark',
								'building',
								'room',
								'ship',
							],
						},
						{
							key: 'parent_location_id',
							label: 'Parent Location',
							type: 'select',
							foreignKey: 'locations',
							displayField: 'name',
						},
						{ key: 'region', label: 'Region', type: 'text' },
						{ key: 'population', label: 'Population', type: 'text' },
						{ key: 'races', label: 'Races', type: 'text' },
						{ key: 'ruler', label: 'Ruler', type: 'text' },
						{ key: 'government_type', label: 'Government Type', type: 'text' },
						{ key: 'planar_type', label: 'Planar Type', type: 'text' },
						{ key: 'size', label: 'Size', type: 'text' },
						{ key: 'exports', label: 'Exports', type: 'text' },
						{ key: 'imports', label: 'Imports', type: 'text' },
						{ key: 'natives', label: 'Natives', type: 'text' },
						{ key: 'description', label: 'Description', type: 'textarea' },
						{ key: 'history', label: 'History', type: 'textarea' },
					],
					listFields: ['name', 'type', 'region'],
				},
				location_connections: {
					category: 'World',
					label: 'Travel Routes',
					tableName: 'location_connections',
					fields: [
						{
							key: 'from_location_id',
							label: 'From',
							type: 'select',
							foreignKey: 'locations',
							displayField: 'name',
							required: true,
						},
						{
							key: 'to_location_id',
							label: 'To',
							type: 'select',
							foreignKey: 'locations',
							displayField: 'name',
							required: true,
						},
						{
							key: 'connection_type',
							label: 'Type',
							type: 'text',
							placeholder: 'Road, Portal, Path...',
						},
						{ key: 'distance', label: 'Distance/Time', type: 'text' },
						{ key: 'description', label: 'Notes', type: 'textarea' },
					],
					listFields: ['from_location_id', 'to_location_id', 'connection_type'],
				},
				location_features: {
					category: 'World',
					label: 'Location Features',
					fields: [
						{
							key: 'location_id',
							label: 'Location',
							type: 'select',
							foreignKey: 'locations',
							displayField: 'name',
							required: true,
						},
						{
							key: 'feature',
							label: 'Feature Name',
							type: 'text',
							required: true,
						},
						{ key: 'description', label: 'Description', type: 'textarea' },
					],
					listFields: ['location_id', 'feature'],
				},
				location_threats: {
					category: 'World',
					label: 'Location Threats',
					fields: [
						{
							key: 'location_id',
							label: 'Location',
							type: 'select',
							foreignKey: 'locations',
							displayField: 'name',
							required: true,
						},
						{ key: 'threat', label: 'Threat', type: 'text', required: true },
						{
							key: 'is_active',
							label: 'Active?',
							type: 'select',
							options: ['true', 'false'],
							default: 'true',
						},
						{ key: 'description', label: 'Details', type: 'textarea' },
					],
					listFields: ['location_id', 'threat', 'is_active'],
				},
				factions: {
					category: 'World',
					label: 'Factions',
					fields: [
						{ key: 'name', label: 'Name', type: 'text', required: true },
						{ key: 'type', label: 'Type', type: 'text' },
						{
							key: 'leader_npc_id',
							label: 'Leader',
							type: 'select',
							foreignKey: 'npcs',
							displayField: 'name',
						},
						{ key: 'description', label: 'Description', type: 'textarea' },
					],
					listFields: ['name', 'type'],
				},

				// --- PEOPLE ---
				characters: {
					category: 'People',
					label: 'PCs',
					fields: [
						{ key: 'name', label: 'Name', type: 'text', required: true },
						{ key: 'race', label: 'Race', type: 'text' },
						{ key: 'class', label: 'Class', type: 'text' },
						{ key: 'level', label: 'Level', type: 'number', default: 1 },
						{ key: 'icon', label: 'Icon', type: 'text' },
						{ key: 'image_bg', label: 'Image Background', type: 'text' },
						{ key: 'background', label: 'Background', type: 'textarea' },
						{
							key: 'short_description',
							label: 'Short Description',
							type: 'textarea',
						},
						{
							key: 'is_active',
							label: 'Active?',
							type: 'select',
							options: ['true', 'false'],
							default: 'true',
						},
						{ key: 'stats', label: 'Stats JSON', type: 'json' },
					],
					listFields: ['name', 'race', 'class', 'level'],
				},
				character_sessions: {
					category: 'People',
					label: 'PC Attendance',
					tableName: 'character_sessions',
					compositeKeys: ['character_id', 'session_id'],
					fields: [
						{
							key: 'character_id',
							label: 'Character',
							type: 'select',
							foreignKey: 'characters',
							displayField: 'name',
							required: true,
						},
						{
							key: 'session_id',
							label: 'Session',
							type: 'select',
							foreignKey: 'sessions',
							displayField: 'title',
							required: true,
						},
						{ key: 'notes', label: 'Notes', type: 'textarea' },
					],
					listFields: ['character_id', 'session_id'],
				},
				npcs: {
					category: 'People',
					label: 'NPCs',
					fields: [
						{ key: 'name', label: 'Name', type: 'text', required: true },
						{ key: 'role', label: 'Role', type: 'text' },
						{ key: 'race', label: 'Race', type: 'text' },
						{ key: 'class', label: 'Class', type: 'text' },
						{ key: 'gender', label: 'Gender', type: 'text' },
						{
							key: 'status',
							label: 'Status',
							type: 'select',
							options: ['alive', 'dead', 'missing', 'unknown'],
							default: 'alive',
						},
						{
							key: 'affinity',
							label: 'Affinity',
							type: 'select',
							options: ['ally', 'neutral', 'enemy', 'unknown'],
							default: 'unknown',
						},
						{ key: 'personality', label: 'Personality', type: 'textarea' },
						{ key: 'background', label: 'Background', type: 'textarea' },
						{ key: 'description', label: 'Description', type: 'textarea' },
						{ key: 'portrait', label: 'Portrait URL', type: 'text' },
					],
					listFields: ['name', 'role', 'affinity', 'status'],
				},
				npc_relationships: {
					category: 'People',
					label: 'NPC Relationships',
					fields: [
						{
							key: 'npc_id',
							label: 'NPC 1',
							type: 'select',
							foreignKey: 'npcs',
							displayField: 'name',
							required: true,
						},
						{
							key: 'related_npc_id',
							label: 'NPC 2',
							type: 'select',
							foreignKey: 'npcs',
							displayField: 'name',
							required: true,
						},
						{
							key: 'relationship_type',
							label: 'Type',
							type: 'text',
							required: true,
						},
						{ key: 'strength', label: 'Strength (-10 to 10)', type: 'number' },
						{ key: 'description', label: 'Details', type: 'textarea' },
						{
							key: 'established_session_id',
							label: 'Established In Session',
							type: 'select',
							foreignKey: 'sessions',
							displayField: 'title',
						},
					],
					listFields: ['npc_id', 'relationship_type', 'related_npc_id'],
				},
				npc_factions: {
					category: 'People',
					label: 'NPC Factions',
					compositeKeys: ['npc_id', 'faction_id'],
					fields: [
						{
							key: 'npc_id',
							label: 'NPC',
							type: 'select',
							foreignKey: 'npcs',
							displayField: 'name',
							required: true,
						},
						{
							key: 'faction_id',
							label: 'Faction',
							type: 'select',
							foreignKey: 'factions',
							displayField: 'name',
							required: true,
						},
						{ key: 'role', label: 'Role', type: 'text' },
						{ key: 'rank', label: 'Rank', type: 'text' },
						{
							key: 'joined_session_id',
							label: 'Joined In Session',
							type: 'select',
							foreignKey: 'sessions',
							displayField: 'title',
						},
						{
							key: 'left_session_id',
							label: 'Left In Session',
							type: 'select',
							foreignKey: 'sessions',
							displayField: 'title',
						},
					],
					listFields: ['npc_id', 'faction_id', 'role'],
				},
				npc_locations: {
					category: 'People',
					label: 'NPC Locations',
					compositeKeys: ['npc_id', 'location_id'],
					fields: [
						{
							key: 'npc_id',
							label: 'NPC',
							type: 'select',
							foreignKey: 'npcs',
							displayField: 'name',
							required: true,
						},
						{
							key: 'location_id',
							label: 'Location',
							type: 'select',
							foreignKey: 'locations',
							displayField: 'name',
							required: true,
						},
						{
							key: 'is_primary',
							label: 'Primary Home?',
							type: 'select',
							options: ['true', 'false'],
							default: 'false',
						},
						{
							key: 'arrival_session_id',
							label: 'Arrived In Session',
							type: 'select',
							foreignKey: 'sessions',
							displayField: 'title',
						},
						{
							key: 'departure_session_id',
							label: 'Departed In Session',
							type: 'select',
							foreignKey: 'sessions',
							displayField: 'title',
						},
						{ key: 'notes', label: 'Notes', type: 'textarea' },
					],
					listFields: ['npc_id', 'location_id', 'is_primary'],
				},
				npc_items: {
					category: 'People',
					label: 'NPC Inventory',
					fields: [
						{
							key: 'npc_id',
							label: 'NPC',
							type: 'select',
							foreignKey: 'npcs',
							displayField: 'name',
							required: true,
						},
						{ key: 'item_name', label: 'Item', type: 'text', required: true },
						{ key: 'description', label: 'Description', type: 'textarea' },
						{
							key: 'acquired_session_id',
							label: 'Acquired In Session',
							type: 'select',
							foreignKey: 'sessions',
							displayField: 'title',
						},
						{
							key: 'lost_session_id',
							label: 'Lost In Session',
							type: 'select',
							foreignKey: 'sessions',
							displayField: 'title',
						},
					],
					listFields: ['npc_id', 'item_name'],
				},

				// --- QUESTS ---
				quests: {
					category: 'Quests',
					label: 'Quests',
					fields: [
						{ key: 'title', label: 'Title', type: 'text', required: true },
						{
							key: 'status',
							label: 'Status',
							type: 'select',
							options: ['active', 'completed', 'failed', 'on-hold', 'abandoned'],
							default: 'active',
						},
						{
							key: 'priority',
							label: 'Priority',
							type: 'select',
							options: ['low', 'medium', 'high', 'urgent'],
							default: 'medium',
						},
						{ key: 'description', label: 'Description', type: 'textarea' },
					],
					listFields: ['title', 'status', 'priority'],
				},
				quest_objectives: {
					category: 'Quests',
					label: 'Quest Objectives',
					fields: [
						{
							key: 'quest_id',
							label: 'Quest',
							type: 'select',
							foreignKey: 'quests',
							displayField: 'title',
							required: true,
						},
						{
							key: 'description',
							label: 'Objective',
							type: 'text',
							required: true,
						},
						{
							key: 'status',
							label: 'Status',
							type: 'select',
							options: ['pending', 'in-progress', 'completed', 'failed'],
							default: 'pending',
						},
						{
							key: 'order_index',
							label: 'Order',
							type: 'number',
							required: true,
						},
						{ key: 'details', label: 'Details JSON', type: 'json' },
						{
							key: 'completed_session_id',
							label: 'Completed In Session',
							type: 'select',
							foreignKey: 'sessions',
							displayField: 'title',
						},
					],
					listFields: ['quest_id', 'order_index', 'description', 'status'],
				},
				quest_locations: {
					category: 'Quests',
					label: 'Quest Locations',
					compositeKeys: ['quest_id', 'location_id'],
					fields: [
						{
							key: 'quest_id',
							label: 'Quest',
							type: 'select',
							foreignKey: 'quests',
							displayField: 'title',
							required: true,
						},
						{
							key: 'location_id',
							label: 'Location',
							type: 'select',
							foreignKey: 'locations',
							displayField: 'name',
							required: true,
						},
						{ key: 'relevance', label: 'Relevance', type: 'text' },
					],
					listFields: ['quest_id', 'location_id', 'relevance'],
				},
				quest_npcs: {
					category: 'Quests',
					label: 'Quest NPCs',
					compositeKeys: ['quest_id', 'npc_id'],
					fields: [
						{
							key: 'quest_id',
							label: 'Quest',
							type: 'select',
							foreignKey: 'quests',
							displayField: 'title',
							required: true,
						},
						{
							key: 'npc_id',
							label: 'NPC',
							type: 'select',
							foreignKey: 'npcs',
							displayField: 'name',
							required: true,
						},
						{ key: 'involvement', label: 'Involvement', type: 'text' },
					],
					listFields: ['quest_id', 'npc_id', 'involvement'],
				},

				// --- COMBAT ---
				encounters: {
					category: 'Combat',
					label: 'Encounters',
					fields: [
						{ key: 'name', label: 'Name', type: 'text', required: true },
						{
							key: 'session_id',
							label: 'Session',
							type: 'select',
							foreignKey: 'sessions',
							displayField: 'title',
						},
						{
							key: 'location_id',
							label: 'Location',
							type: 'select',
							foreignKey: 'locations',
							displayField: 'name',
						},
						{ key: 'description', label: 'Description', type: 'textarea' },
						{ key: 'notes', label: 'Notes', type: 'textarea' },
						{ key: 'outcome', label: 'Outcome JSON', type: 'json' },
						{ key: 'environment', label: 'Environment JSON', type: 'json' },
					],
					listFields: ['name', 'session_id', 'location_id'],
				},
				encounter_initiative: {
					category: 'Combat',
					label: 'Initiative',
					fields: [
						{
							key: 'encounter_id',
							label: 'Encounter',
							type: 'select',
							foreignKey: 'encounters',
							displayField: 'name',
							required: true,
						},
						{
							key: 'combatant_name',
							label: 'Name',
							type: 'text',
							required: true,
						},
						{
							key: 'combatant_type',
							label: 'Type',
							type: 'select',
							options: ['player', 'npc', 'enemy', 'ally'],
						},
						{
							key: 'initiative_roll',
							label: 'Initiative Roll',
							type: 'number',
							required: true,
						},
						{
							key: 'order_index',
							label: 'Order',
							type: 'number',
							required: true,
						},
						{ key: 'max_hp', label: 'Max HP', type: 'number' },
						{ key: 'current_hp', label: 'Current HP', type: 'number' },
						{ key: 'armor_class', label: 'AC', type: 'number' },
						{ key: 'conditions', label: 'Conditions JSON', type: 'json' },
						{ key: 'notes', label: 'Notes', type: 'textarea' },
					],
					listFields: ['encounter_id', 'order_index', 'combatant_name', 'current_hp'],
				},
				encounter_rounds: {
					category: 'Combat',
					label: 'Rounds',
					fields: [
						{
							key: 'encounter_id',
							label: 'Encounter',
							type: 'select',
							foreignKey: 'encounters',
							displayField: 'name',
							required: true,
						},
						{
							key: 'round_number',
							label: 'Round #',
							type: 'number',
							required: true,
						},
						{ key: 'round_notes', label: 'Notes', type: 'textarea' },
					],
					listFields: ['encounter_id', 'round_number', 'round_notes'],
				},
				encounter_actions: {
					category: 'Combat',
					label: 'Actions',
					fields: [
						{
							key: 'encounter_id',
							label: 'Encounter',
							type: 'select',
							foreignKey: 'encounters',
							displayField: 'name',
							required: true,
						},
						{
							key: 'round_number',
							label: 'Round #',
							type: 'number',
							required: true,
						},
						{
							key: 'action_order',
							label: 'Order',
							type: 'number',
							required: true,
						},
						{ key: 'actor_name', label: 'Actor', type: 'text', required: true },
						{ key: 'action_type', label: 'Action Type', type: 'text' },
						{ key: 'target_name', label: 'Target', type: 'text' },
						{
							key: 'action_description',
							label: 'Action',
							type: 'textarea',
							required: true,
						},
						{ key: 'attack_roll', label: 'Attack Roll', type: 'number' },
						{ key: 'damage_roll', label: 'Damage Roll', type: 'text' },
						{ key: 'damage_dealt', label: 'Damage', type: 'number' },
						{ key: 'result', label: 'Result', type: 'text' },
						{ key: 'notes', label: 'Notes', type: 'textarea' },
					],
					listFields: ['encounter_id', 'round_number', 'actor_name', 'action_description'],
				},
				encounter_consequences: {
					category: 'Combat',
					label: 'Consequences',
					fields: [
						{
							key: 'encounter_id',
							label: 'Encounter',
							type: 'select',
							foreignKey: 'encounters',
							displayField: 'name',
							required: true,
						},
						{
							key: 'consequence_type',
							label: 'Type',
							type: 'select',
							options: ['enemy_defeated', 'item_obtained', 'complication', 'injury', 'consequence', 'discovery'],
							required: true,
						},
						{
							key: 'description',
							label: 'Description',
							type: 'textarea',
							required: true,
						},
						{ key: 'details', label: 'Details JSON', type: 'json' },
					],
					listFields: ['encounter_id', 'consequence_type', 'description'],
				},

				// --- EVENTS ---
				session_events: {
					category: 'Events',
					label: 'Timeline Events',
					fields: [
						{
							key: 'session_id',
							label: 'Session',
							type: 'select',
							foreignKey: 'sessions',
							displayField: 'title',
							required: true,
						},
						{
							key: 'event_order',
							label: 'Order',
							type: 'number',
							required: true,
						},
						{
							key: 'event_type',
							label: 'Type',
							type: 'select',
							required: true,
							options: [
								'npc_introduced',
								'npc_encountered',
								'npc_died',
								'npc_relocated',
								'npc_joined_faction',
								'npc_left_faction',
								'npc_relationship_changed',
								'location_discovered',
								'location_visited',
								'location_changed',
								'quest_started',
								'quest_updated',
								'quest_completed',
								'quest_failed',
								'objective_completed',
								'encounter_fought',
								'item_acquired',
								'item_lost',
								'faction_discovered',
								'character_leveled',
								'story_event',
								'custom',
							],
						},
						{ key: 'title', label: 'Title', type: 'text', required: true },

						// Conditional Fields
						{
							key: 'npc_id',
							label: 'NPC',
							type: 'select',
							foreignKey: 'npcs',
							displayField: 'name',
							visibleIf: {
								field: 'event_type',
								values: [
									'npc_introduced',
									'npc_died',
									'npc_encountered',
									'npc_relocated',
									'npc_joined_faction',
									'npc_left_faction',
									'npc_relationship_changed',
								],
							},
						},
						{
							key: 'location_id',
							label: 'Location',
							type: 'select',
							foreignKey: 'locations',
							displayField: 'name',
							visibleIf: {
								field: 'event_type',
								values: ['location_discovered', 'location_visited', 'location_changed'],
							},
						},
						{
							key: 'quest_id',
							label: 'Quest',
							type: 'select',
							foreignKey: 'quests',
							displayField: 'title',
							visibleIf: {
								field: 'event_type',
								values: ['quest_started', 'quest_updated', 'quest_completed', 'quest_failed'],
							},
						},
						{
							key: 'encounter_id',
							label: 'Encounter',
							type: 'select',
							foreignKey: 'encounters',
							displayField: 'name',
							visibleIf: { field: 'event_type', values: ['encounter_fought'] },
						},
						{
							key: 'faction_id',
							label: 'Faction',
							type: 'select',
							foreignKey: 'factions',
							displayField: 'name',
							visibleIf: {
								field: 'event_type',
								values: ['faction_discovered', 'npc_joined_faction', 'npc_left_faction'],
							},
						},
						{
							key: 'character_id',
							label: 'Character',
							type: 'select',
							foreignKey: 'characters',
							displayField: 'name',
							visibleIf: { field: 'event_type', values: ['character_leveled'] },
						},

						{ key: 'description', label: 'Details', type: 'textarea' },
						{ key: 'event_data', label: 'Event Data JSON', type: 'json' },
					],
					listFields: ['session_id', 'event_order', 'event_type', 'title'],
				},
			};

			// ==========================================
			// 2. STATE
			// ==========================================
			let state = {
				supabase: null,
				campaigns: [],
				currentCampaignId: null,
				activeTab: 'campaigns',
				cache: {},
				editingItem: null,
				tomSelectInstances: [],
				pendingQuickAdd: null,
				// Advanced Features
				filters: {}, // Key-Value pairs for filtering
				sort: { field: null, direction: 'asc' }, // { field: 'name', direction: 'asc' }
			};

			// ==========================================
			// 3. CORE
			// ==========================================
			function initApp() {
				const url = document.getElementById('sbUrl').value || localStorage.getItem('sb_url');
				const key = document.getElementById('sbKey').value || localStorage.getItem('sb_key');

				if (!url || !key) return showToast('Please enter database credentials', 'error');

				try {
					state.supabase = supabase.createClient(url, key);
					localStorage.setItem('sb_url', url);
					localStorage.setItem('sb_key', key);

					document.getElementById('configSection').classList.add('hidden');
					document.getElementById('appContent').classList.remove('hidden');

					loadCampaigns();
					renderNav();
				} catch (e) {
					showToast('Connection failed: ' + e.message, 'error');
				}
			}

			function toggleConfig() {
				document.getElementById('configSection').classList.toggle('hidden');
			}

			async function loadCampaigns() {
				const { data, error } = await state.supabase.from('campaigns').select('*');
				if (error) return showToast(error.message, 'error');
				state.campaigns = data || [];
				const select = document.getElementById('campaignSelector');
				select.innerHTML = '<option value="">Select Campaign...</option>';
				state.campaigns.forEach((c) => {
					select.innerHTML += `<option value="${c.id}">${c.name}</option>`;
				});
				const savedId = localStorage.getItem('last_campaign_id');
				if (savedId && state.campaigns.find((c) => c.id == savedId)) {
					select.value = savedId;
					handleCampaignSwitch();
				}
			}

			async function handleCampaignSwitch() {
				const id = document.getElementById('campaignSelector').value;
				state.currentCampaignId = id;
				localStorage.setItem('last_campaign_id', id);
				const campaign = state.campaigns.find((c) => c.id == id);
				document.getElementById('activeCampaignDisplay').innerText = campaign ? campaign.name : 'No Campaign Selected';
				state.cache = {};
				if (state.activeTab) switchTab(state.activeTab);
			}

			// ==========================================
			// 4. DATA LAYER
			// ==========================================
			async function fetchData(tableName) {
				let query = state.supabase.from(tableName).select('*');

				// Basic filtering for non-junction tables
				if (state.currentCampaignId && !NO_CAMPAIGN_ID_TABLES.includes(tableName)) {
					query = query.eq('campaign_id', state.currentCampaignId);
				}

				const { data, error } = await query;
				if (error) {
					console.error(error);
					return [];
				}
				state.cache[tableName] = data;
				return data;
			}

			function resolveFK(tableName, id, displayField) {
				if (!id) return '-';
				const data = state.cache[tableName];
				if (!data) return id;
				const item = data.find((d) => d.id === id);
				return item ? item[displayField] : id;
			}

			// --- CROSS REFERENCE LOGIC ---
			async function getCrossReferences(targetSchemaKey, targetId) {
				if (!targetId) return [];

				const results = [];

				// Iterate over all schemas to see who points to targetSchemaKey
				for (const [schemaKey, schema] of Object.entries(SCHEMAS)) {
					const fkFields = schema.fields.filter((f) => f.foreignKey === targetSchemaKey);

					if (fkFields.length > 0) {
						const tableName = schema.tableName || schemaKey;

						for (const field of fkFields) {
							// Query DB for accuracy (cache might be partial)
							let query = state.supabase.from(tableName).select(`id, ${schema.listFields.join(',')}`);

							if (schema.compositeKeys) {
								// Composite keys don't usually have a single ID, we fetch enough to identify
								query = query.eq(field.key, targetId);
							} else {
								query = query.eq(field.key, targetId);
							}

							const { data, error } = await query;

							if (data && data.length > 0) {
								results.push({
									schemaKey: schemaKey,
									category: schema.category,
									label: schema.label,
									items: data,
									fieldLabel: field.label,
								});
							}
						}
					}
				}
				return results;
			}

			// ==========================================
			// 5. RENDERERS
			// ==========================================
			function renderNav() {
				const container = document.getElementById('navContainer');
				const categories = {};
				Object.entries(SCHEMAS).forEach(([key, schema]) => {
					if (!categories[schema.category]) categories[schema.category] = [];
					categories[schema.category].push({ key, label: schema.label });
				});
				let html = '';
				Object.keys(categories).forEach((cat) => {
					html += `<div class="nav-section"><div class="nav-title">${cat}</div>`;
					categories[cat].forEach((item) => {
						html += `<button class="nav-item ${item.key === state.activeTab ? 'active' : ''}" onclick="switchTab('${
							item.key
						}')">${item.label}</button>`;
					});
					html += `</div>`;
				});
				container.innerHTML = html;
			}

			async function switchTab(key) {
				state.activeTab = key;
				state.filters = {}; // Reset filters
				state.sort = { field: null, direction: 'asc' }; // Reset sort

				renderNav();
				resetForm();

				// UI Resets
				document.getElementById('filterPanelContainer').classList.add('hidden');
				document.getElementById('btnToggleFilters').classList.remove('btn-active');
				document.getElementById('tableStatus').classList.add('hidden');
				document.getElementById('crossRefContainer').classList.add('hidden');

				const schema = SCHEMAS[key];
				const tableName = schema.tableName || key;

				document.getElementById('formTitle').innerText = `Editor: ${schema.label}`;
				document.getElementById('tableTitle').innerText = `Data: ${schema.label}`;

				// Fetch Dependencies
				const fks = schema.fields.filter((f) => f.foreignKey);
				for (let fk of fks) await fetchData(fk.foreignKey);

				const data = await fetchData(tableName);
				renderForm(key, 'dynamicForm');
				renderFilterPanel(key); // Prep filters
				renderTable(key); // Uses cached data + filter/sort
			}

			function renderForm(schemaKey, formId) {
				const schema = SCHEMAS[schemaKey];
				const form = document.getElementById(formId);
				form.innerHTML = '';

				if (formId === 'dynamicForm') {
					state.tomSelectInstances.forEach((inst) => inst.destroy());
					state.tomSelectInstances = [];
				}

				schema.fields.forEach((field) => {
					const div = document.createElement('div');
					div.className = 'form-group';
					div.dataset.fieldKey = field.key;

					const label = document.createElement('label');
					label.innerText = field.label + (field.required ? ' *' : '');
					div.appendChild(label);

					let inputContainer = document.createElement('div');

					if (field.type === 'json') {
						const toolbar = document.createElement('div');
						toolbar.className = 'json-toolbar';
						toolbar.innerHTML = `<button type="button" class="btn btn-sm btn-outline" onclick="formatJsonField('${formId}', '${field.key}')">‚ú® Format JSON</button>`;
						div.appendChild(toolbar);
					}

					if (field.type === 'select') {
						inputContainer.className = 'input-group';
						const select = document.createElement('select');
						select.name = field.key;
						select.id = `${formId}_${field.key}`;
						select.innerHTML = '<option value="">-- Select --</option>';

						if (field.foreignKey) {
							const data = state.cache[field.foreignKey] || [];
							data.sort((a, b) => (a[field.displayField] || '').localeCompare(b[field.displayField] || ''));
							data.forEach((item) => {
								const opt = document.createElement('option');
								opt.value = item.id;
								opt.innerText = item[field.displayField] || item.name || item.id;
								select.appendChild(opt);
							});
							inputContainer.appendChild(select);

							const btn = document.createElement('button');
							btn.type = 'button';
							btn.className = 'btn btn-success btn-icon';
							btn.innerText = '+';
							btn.title = 'Quick Add New Item';
							btn.onclick = () => openQuickAdd(field.foreignKey, select.id);
							inputContainer.appendChild(btn);
						} else if (field.options) {
							field.options.forEach((opt) => {
								const optEl = document.createElement('option');
								optEl.value = opt;
								optEl.innerText = opt;
								select.appendChild(optEl);
							});
							inputContainer.appendChild(select);
						}
						div.appendChild(inputContainer);
					} else if (field.type === 'textarea' || field.type === 'json') {
						const input = document.createElement('textarea');
						input.name = field.key;
						input.rows = field.type === 'json' ? 5 : 3;
						if (field.type === 'json') {
							input.placeholder = '{"key": "value"}';
							input.className = 'code-input';
						}
						div.appendChild(input);
					} else {
						const input = document.createElement('input');
						input.type = field.type;
						input.name = field.key;
						div.appendChild(input);
					}

					const inputEl = div.querySelector('input, select, textarea');
					if (inputEl) {
						inputEl.onchange = () => checkDependencies(schemaKey, formId);
						if (field.required) inputEl.required = true;
						if (field.default) inputEl.value = field.default;
					}

					form.appendChild(div);
				});

				const btn = document.createElement('button');
				btn.type = 'submit';
				btn.className = 'btn';
				btn.style.width = '100%';
				btn.innerText = formId === 'quickAddForm' ? 'Save & Close' : state.editingItem ? 'Update Item' : 'Create Item';
				form.appendChild(btn);

				checkDependencies(schemaKey, formId);

				setTimeout(() => {
					const selects = form.querySelectorAll('select');
					selects.forEach((s) => {
						if (s.options.length > 5 || s.id.includes('_id')) {
							const ts = new TomSelect(`#${s.id}`, {
								create: false,
								sortField: { field: 'text', direction: 'asc' },
								maxOptions: 50,
							});
							if (formId === 'dynamicForm') state.tomSelectInstances.push(ts);
						}
					});
				}, 50);
			}

			// --- FILTERING UI & LOGIC ---
			function toggleFilterPanel() {
				const panel = document.getElementById('filterPanelContainer');
				const btn = document.getElementById('btnToggleFilters');
				panel.classList.toggle('hidden');
				btn.classList.toggle('btn-active');
			}

			function renderFilterPanel(schemaKey) {
				const schema = SCHEMAS[schemaKey];
				const container = document.getElementById('filterPanelContainer');
				container.innerHTML = '';

				// Filterable fields (exclude JSON, textareas for now for simplicity)
				const filterableFields = schema.fields.filter((f) => ['text', 'number', 'select', 'date'].includes(f.type));

				filterableFields.forEach((field) => {
					const wrapper = document.createElement('div');
					wrapper.className = 'filter-item';

					const label = document.createElement('label');
					label.innerText = field.label;
					wrapper.appendChild(label);

					if (field.type === 'select') {
						const select = document.createElement('select');
						select.innerHTML = '<option value="">All</option>';
						if (field.options) {
							field.options.forEach((o) => (select.innerHTML += `<option value="${o}">${o}</option>`));
						} else if (field.foreignKey) {
							const data = state.cache[field.foreignKey] || [];
							data.sort((a, b) => (a.name || '').localeCompare(b.name || ''));
							data.forEach(
								(o) => (select.innerHTML += `<option value="${o.id}">${o[field.displayField] || o.name}</option>`)
							);
						}
						select.onchange = (e) => applyFilter(field.key, e.target.value);
						wrapper.appendChild(select);
					} else {
						const input = document.createElement('input');
						input.type = field.type;
						input.placeholder = 'Filter...';
						input.onkeyup = (e) => applyFilter(field.key, e.target.value);
						wrapper.appendChild(input);
					}
					container.appendChild(wrapper);
				});

				// Clear Button
				const clearBtn = document.createElement('button');
				clearBtn.className = 'btn btn-sm btn-danger';
				clearBtn.style.marginTop = '18px';
				clearBtn.innerHTML = '‚úï Clear';
				clearBtn.onclick = clearFilters;
				container.appendChild(clearBtn);
			}

			function applyFilter(key, value) {
				if (value === '') delete state.filters[key];
				else state.filters[key] = value;
				renderTable(state.activeTab);
			}

			function clearFilters() {
				state.filters = {};
				const inputs = document.querySelectorAll('#filterPanelContainer input, #filterPanelContainer select');
				inputs.forEach((i) => (i.value = ''));
				renderTable(state.activeTab);
			}

			function handleSort(fieldKey) {
				if (state.sort.field === fieldKey) {
					state.sort.direction = state.sort.direction === 'asc' ? 'desc' : 'asc';
				} else {
					state.sort.field = fieldKey;
					state.sort.direction = 'asc';
				}
				renderTable(state.activeTab);
			}

			// --- TABLE RENDERING WITH FILTERS ---
			function renderTable(schemaKey) {
				const schema = SCHEMAS[schemaKey];
				const container = document.getElementById('dataTable');
				const rawData = state.cache[schemaKey] || [];

				// 1. Filter Data
				let processedData = rawData.filter((item) => {
					for (const [key, val] of Object.entries(state.filters)) {
						const itemVal = item[key];
						if (itemVal === null || itemVal === undefined) return false;

						// Partial match for strings, exact for others
						if (
							typeof itemVal === 'string' &&
							!schema.fields.find((f) => f.key === key)?.foreignKey &&
							!schema.fields.find((f) => f.key === key)?.options
						) {
							if (!itemVal.toLowerCase().includes(val.toLowerCase())) return false;
						} else {
							// Exact match for IDs, Numbers, Dates, Selects
							if (itemVal.toString() != val) return false;
						}
					}
					return true;
				});

				// 2. Sort Data
				if (state.sort.field) {
					processedData.sort((a, b) => {
						let valA = a[state.sort.field];
						let valB = b[state.sort.field];

						// Resolve FK for sorting if needed
						const fDef = schema.fields.find((f) => f.key === state.sort.field);
						if (fDef && fDef.foreignKey) {
							valA = resolveFK(fDef.foreignKey, valA, fDef.displayField);
							valB = resolveFK(fDef.foreignKey, valB, fDef.displayField);
						}

						if (valA < valB) return state.sort.direction === 'asc' ? -1 : 1;
						if (valA > valB) return state.sort.direction === 'asc' ? 1 : -1;
						return 0;
					});
				}

				// Update Status Text
				const statusEl = document.getElementById('tableStatus');
				if (Object.keys(state.filters).length > 0) {
					statusEl.innerText = `${processedData.length} / ${rawData.length}`;
					statusEl.classList.remove('hidden');
				} else {
					statusEl.classList.add('hidden');
				}

				if (!processedData || processedData.length === 0) {
					container.innerHTML =
						'<div style="padding:20px; text-align:center; color:var(--text-muted)">No data matches filters.</div>';
					return;
				}

				let html = '<table><thead><tr>';
				schema.listFields.forEach((f) => {
					const fDef = schema.fields.find((field) => field.key === f);
					const sortIcon = state.sort.field === f ? (state.sort.direction === 'asc' ? ' ‚ñ≤' : ' ‚ñº') : '';
					html += `<th onclick="handleSort('${f}')">${fDef ? fDef.label : f}${sortIcon}</th>`;
				});
				html += '<th>Actions</th></tr></thead><tbody>';

				processedData.forEach((item) => {
					let itemId;
					if (schema.compositeKeys) {
						itemId = schema.compositeKeys.map((k) => `${k}:${item[k]}`).join(',');
					} else {
						itemId = item.id;
					}

					html += '<tr>';
					schema.listFields.forEach((key) => {
						const fDef = schema.fields.find((field) => field.key === key);
						let val = item[key];
						if (fDef && fDef.foreignKey) {
							val = resolveFK(fDef.foreignKey, val, fDef.displayField);
							val = `<span class="tag">${val}</span>`;
						} else {
							if (typeof val === 'string' && val.length > 50) val = val.substring(0, 50) + '...';
							if (val === null || val === undefined) val = '-';
						}
						html += `<td>${val}</td>`;
					});
					html += `<td>
                        <button class="btn btn-sm btn-outline" onclick="editItem('${schemaKey}', '${itemId}')">Edit</button>
                        <button class="btn btn-sm btn-danger" onclick="deleteItem('${schemaKey}', '${itemId}')">Del</button>
                    </td></tr>`;
				});
				html += '</tbody></table>';
				container.innerHTML = html;
			}

			// --- CROSS REFERENCE PANEL ---
			async function renderCrossReferences(schemaKey, itemId) {
				const container = document.getElementById('crossRefList');
				const wrapper = document.getElementById('crossRefContainer');
				const countEl = document.getElementById('refCount');

				container.innerHTML = '<div style="padding:10px; text-align:center;">Searching dependencies...</div>';
				wrapper.classList.remove('hidden');

				const refs = await getCrossReferences(schemaKey, itemId);

				let total = 0;
				refs.forEach((r) => (total += r.items.length));
				countEl.innerText = `${total} refs`;

				if (refs.length === 0) {
					container.innerHTML =
						'<div style="padding:10px; text-align:center; color:var(--success)">No dependencies found. Safe to delete.</div>';
					return;
				}

				// Group by Category
				const grouped = {};
				refs.forEach((ref) => {
					if (!grouped[ref.category]) grouped[ref.category] = [];
					grouped[ref.category].push(ref);
				});

				let html = '';
				Object.keys(grouped).forEach((cat) => {
					html += `<div class="ref-category"><div class="ref-header">${cat}</div>`;
					grouped[cat].forEach((g) => {
						g.items.forEach((item) => {
							const label = item.name || item.title || item.description || `ID: ${item.id}`;
							const idStr = g.items[0].id ? item.id : 'comp'; // composite handle later
							// Create link to jump
							html += `<div class="ref-tag" onclick="jumpToRef('${g.schemaKey}', '${item.id || ''}')">
                                <span class="ref-id">[${g.label}]</span> ${label}
                            </div>`;
						});
					});
					html += `</div>`;
				});
				container.innerHTML = html;
			}

			function jumpToRef(schemaKey, itemId) {
				switchTab(schemaKey);
				// Auto filter to find it
				if (itemId) {
					const idField = SCHEMAS[schemaKey].fields.find((f) => f.key === 'id'); // Usually id
					if (idField) {
						state.filters['id'] = itemId;
						// Re-render panel to show filter
						const input = document.querySelector(`#filterPanelContainer input[type="number"]`); // simplistic guess
						// Better: just set state and render
						document.getElementById('filterPanelContainer').classList.remove('hidden');
						renderTable(schemaKey);

						// Populate inputs visually
						renderFilterPanel(schemaKey); // reset inputs
						// This part is tricky to sync visual inputs with state efficiently without ID matching
						// For now, just filtering the table is sufficient feedback.
					}
				}
			}

			function checkDependencies(schemaKey, formId) {
				const schema = SCHEMAS[schemaKey];
				const form = document.getElementById(formId);
				const formData = new FormData(form);

				schema.fields.forEach((field) => {
					if (field.visibleIf) {
						const dep = field.visibleIf;
						const val = formData.get(dep.field);
						const div = form.querySelector(`div[data-field-key="${field.key}"]`);
						if (div) {
							const visible = dep.values.includes(val);
							div.classList.toggle('hidden', !visible);
							const el = div.querySelector('input, select, textarea');
							if (el) el.required = visible && field.required;
						}
					}
				});
			}

			// ==========================================
			// 6. HELPERS & UTILS
			// ==========================================

			function formatJsonField(formId, fieldName) {
				const form = document.getElementById(formId);
				const el = form.querySelector(`textarea[name="${fieldName}"]`);
				try {
					if (!el.value) return;
					const obj = JSON.parse(el.value);
					el.value = JSON.stringify(obj, null, 4);
					showToast('JSON Formatted', 'success');
				} catch (e) {
					showToast('Invalid JSON Syntax', 'error');
				}
			}

			function extractFormData(form, schemaKey) {
				const schema = SCHEMAS[schemaKey];
				const formData = new FormData(form);
				const payload = {};
				const tableName = schema.tableName || schemaKey;

				for (let [key, value] of formData.entries()) {
					if (value === '') {
						payload[key] = null;
					} else {
						const fDef = schema.fields.find((f) => f.key === key);
						if (fDef && fDef.type === 'json') {
							try {
								payload[key] = JSON.parse(value);
							} catch (e) {
								showToast(`Invalid JSON in ${fDef.label}`, 'error');
								return null;
							}
						} else {
							payload[key] = value;
						}
					}
				}

				if (state.currentCampaignId && !NO_CAMPAIGN_ID_TABLES.includes(tableName)) {
					payload.campaign_id = state.currentCampaignId;
				}

				return payload;
			}

			function openQuickAdd(foreignSchemaKey, triggerSelectId) {
				state.pendingQuickAdd = {
					schemaKey: foreignSchemaKey,
					triggerId: triggerSelectId,
				};
				const schema = SCHEMAS[foreignSchemaKey];
				document.getElementById('modalTitle').innerText = `Quick Add: ${schema.label}`;
				document.getElementById('quickAddModal').classList.remove('hidden');
				renderForm(foreignSchemaKey, 'quickAddForm');
			}

			function closeQuickAdd() {
				document.getElementById('quickAddModal').classList.add('hidden');
				state.pendingQuickAdd = null;
			}

			async function handleQuickAddSubmit(e) {
				e.preventDefault();
				const schemaKey = state.pendingQuickAdd.schemaKey;
				const payload = extractFormData(e.target, schemaKey);

				if (!payload) return;

				const tableName = SCHEMAS[schemaKey].tableName || schemaKey;
				const { data, error } = await state.supabase.from(tableName).insert([payload]).select();

				if (error) {
					showToast(error.message, 'error');
					return;
				}

				const newItem = data[0];
				showToast(`Created ${newItem.name || 'Item'}`, 'success');
				closeQuickAdd();

				const currentData = state.cache[schemaKey] || [];
				currentData.push(newItem);
				state.cache[schemaKey] = currentData;

				const triggerId = state.pendingQuickAdd.triggerId;
				const selectEl = document.getElementById(triggerId);

				if (selectEl && selectEl.tomselect) {
					const schema = SCHEMAS[schemaKey];
					const displayKey = schema.fields.find((f) => f.key === 'name' || f.displayField)?.key || 'name';

					selectEl.tomselect.addOption({
						value: newItem.id,
						text: newItem[displayKey] || newItem.name || newItem.id,
					});
					selectEl.tomselect.addItem(newItem.id);
				}
			}

			// ==========================================
			// 7. MAIN ACTIONS
			// ==========================================

			async function handleFormSubmit(e) {
				e.preventDefault();
				if (!state.currentCampaignId && state.activeTab !== 'campaigns') {
					return showToast('Select a campaign first', 'error');
				}

				const schemaKey = state.activeTab;
				const tableName = SCHEMAS[schemaKey].tableName || schemaKey;
				const payload = extractFormData(e.target, schemaKey);
				if (!payload) return;

				let error;
				if (state.editingItem) {
					let query = state.supabase.from(tableName).update(payload);
					if (SCHEMAS[schemaKey].compositeKeys) {
						SCHEMAS[schemaKey].compositeKeys.forEach((k) => {
							query = query.eq(k, state.editingItem[k]);
						});
					} else {
						query = query.eq('id', state.editingItem.id);
					}
					const res = await query;
					error = res.error;
				} else {
					const res = await state.supabase.from(tableName).insert([payload]);
					error = res.error;
				}

				if (error) {
					showToast(error.message, 'error');
				} else {
					showToast('Saved!', 'success');
					resetForm();
					document.getElementById('crossRefContainer').classList.add('hidden'); // Hide refs on save
					refreshTable();
				}
			}

			function editItem(schemaKey, itemIdentifier) {
				const schema = SCHEMAS[schemaKey];
				let item;

				if (schema.compositeKeys) {
					const parts = itemIdentifier.split(',');
					const criteria = {};
					parts.forEach((part) => {
						const [key, val] = part.split(':');
						criteria[key] = val;
					});
					item = state.cache[schemaKey].find((i) => schema.compositeKeys.every((k) => i[k] == criteria[k]));
				} else {
					item = state.cache[schemaKey].find((i) => i.id == itemIdentifier);
				}

				if (!item) return showToast('Error: Item not found in cache', 'error');

				state.editingItem = item;
				const form = document.getElementById('dynamicForm');

				Object.keys(item).forEach((key) => {
					const input = form.elements[key];
					if (input) {
						if (typeof item[key] === 'object' && item[key] !== null) {
							input.value = JSON.stringify(item[key], null, 4);
						} else {
							if (input.tagName === 'SELECT' && input.tomselect) {
								input.tomselect.setValue(item[key]);
							} else {
								input.value = item[key];
							}
						}
					}
				});

				checkDependencies(schemaKey, 'dynamicForm');
				document.getElementById('formTitle').innerText = `Editing Item`;
				const btn = form.querySelector('button[type="submit"]');
				btn.innerText = 'Update Item';
				btn.classList.remove('btn-primary');
				btn.style.background = 'var(--warning)';

				// Trigger Cross Reference Check
				if (!schema.compositeKeys) {
					renderCrossReferences(schemaKey, item.id);
				}
			}

			async function deleteItem(schemaKey, itemIdentifier) {
				const schema = SCHEMAS[schemaKey];
				let item;

				if (schema.compositeKeys) {
					const parts = itemIdentifier.split(',');
					const criteria = {};
					parts.forEach((part) => {
						const [key, val] = part.split(':');
						criteria[key] = val;
					});
					item = state.cache[schemaKey].find((i) => schema.compositeKeys.every((k) => i[k] == criteria[k]));
				} else {
					item = state.cache[schemaKey].find((i) => i.id == itemIdentifier);
				}

				if (!item) return showToast('Error: Item not found in cache', 'error');

				// Check Dependencies for normal keys
				if (!schema.compositeKeys) {
					const refs = await getCrossReferences(schemaKey, item.id);
					if (refs.length > 0) {
						let msg = `Cannot delete this item. It is referenced by ${refs.reduce(
							(acc, r) => acc + r.items.length,
							0
						)} other items:\n\n`;
						refs.forEach((r) => {
							msg += `- ${r.label}: ${r.items.length} items\n`;
						});
						alert(msg);
						return;
					}
				}

				if (!confirm('Are you sure you want to delete this?')) return;

				const tableName = schema.tableName || schemaKey;

				let query = state.supabase.from(tableName).delete();
				if (schema.compositeKeys) {
					schema.compositeKeys.forEach((k) => {
						query = query.eq(k, item[k]);
					});
				} else {
					query = query.eq('id', item.id);
				}

				const { error } = await query;
				if (error) showToast(error.message, 'error');
				else {
					showToast('Deleted', 'success');
					document.getElementById('crossRefContainer').classList.add('hidden');
					resetForm();
					refreshTable();
				}
			}

			function resetForm() {
				state.editingItem = null;
				const form = document.getElementById('dynamicForm');
				if (form) {
					form.reset();
					state.tomSelectInstances.forEach((ts) => ts.clear());
					const btn = form.querySelector('button[type="submit"]');
					if (btn) {
						btn.innerText = 'Create Item';
						btn.style.background = 'var(--accent)';
					}
				}
				checkDependencies(state.activeTab, 'dynamicForm');
				document.getElementById('crossRefContainer').classList.add('hidden');
				document.getElementById('formTitle').innerText = `Editor`;
			}

			function refreshTable() {
				renderTable(state.activeTab);
			}

			function showToast(msg, type) {
				const el = document.getElementById('toast');
				el.innerText = msg;
				el.className = `toast show ${type}`;
				setTimeout(() => el.classList.remove('show'), 3000);
			}

			window.onload = () => {
				if (localStorage.getItem('sb_url')) initApp();
				else toggleConfig();
			};
		</script>
	</body>
</html>
