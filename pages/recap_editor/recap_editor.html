<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>D&D Recap Entity Formatter</title>
	</head>
	<body>
		<div id="formatter-container"></div>

		<script>
			class RecapFormatter {
				constructor(options = {}) {
					// Initialize entity categories
					this.entities = {
						character: options.characters || [],
						location: options.locations || [],
						class: options.classes || [],
						subclass: options.subclasses || [],
						guild: options.guilds || [],
						item: options.items || [],
						race: options.races || [],
						npc: options.npc || [],
					};

					// State for the output mode
					this.outputAsHtml = true;

					// Element references
					this.inputElement = null;
					this.outputElement = null;
					this.previewElement = null;
					this.formatButton = null;
					this.copyButton = null;
					this.htmlToggle = null;

					// Initialize entity maps for quick lookup
					this.entityMaps = {};
					for (const [type, list] of Object.entries(this.entities)) {
						this.entityMaps[type] = new Map();
						if (list.length) {
							list.forEach((entityName) => {
								this.entityMaps[type].set(entityName.toLowerCase(), entityName);
							});
						}
					}
				}

				init(containerId) {
					const container = document.getElementById(containerId);
					if (!container) {
						console.error('RecapFormatter: Container element not found:', containerId);
						return;
					}

					container.innerHTML = `
                        <div class="formatter-container">
                            <div class="formatter-header">
                                <h2>D&D Recap Entity Formatter</h2>
                            </div>
                            <div class="formatter-main">
                                <div class="formatter-input-section">
                                    <h3>Input Plain Text</h3>
                                    <textarea id="recap-input" placeholder="Paste your plain text recap here..."></textarea>
                                    <div class="formatter-controls">
                                        <button id="format-button">Format Text</button>
                                        <button id="add-entity-button">Add Entity</button>
                                        <button id="add-image-button">Add Image</button>
                                        <div class="toggle-switch">
                                            <input type="checkbox" id="html-toggle" checked>
                                            <label for="html-toggle" class="toggle-label">HTML Output</label>
                                        </div>
                                    </div>
                                </div>
                                <div class="formatter-output-section">
                                    <h3>Formatted HTML</h3>
                                    <textarea id="recap-output" readonly></textarea>
                                    <button id="copy-button">Copy HTML</button>
                                </div>
                            </div>
                            <div class="formatter-preview-section">
                                <h3>Preview</h3>
                                <div id="recap-preview" class="preview-content"></div>
                            </div>
                        </div>
                    `;

					// Get references to elements
					this.inputElement = document.getElementById('recap-input');
					this.outputElement = document.getElementById('recap-output');
					this.previewElement = document.getElementById('recap-preview');
					this.formatButton = document.getElementById('format-button');
					this.copyButton = document.getElementById('copy-button');
					this.htmlToggle = document.getElementById('html-toggle');
					const addEntityButton = document.getElementById('add-entity-button');
					const addImageButton = document.getElementById('add-image-button');

					// Add event listeners
					this.formatButton.addEventListener('click', () => this.formatText());
					this.copyButton.addEventListener('click', () => this.copyToClipboard());
					this.htmlToggle.addEventListener('change', () => this.handleToggleChange());
					addEntityButton.addEventListener('click', () => this.showEntityModal());
					addImageButton.addEventListener('click', () => this.showImageModal());

					this.addStyles();
				}

				addStyles() {
					const styleElement = document.createElement('style');
					styleElement.textContent = `
                        .formatter-container { font-family: Arial, sans-serif; max-width: 1200px; margin: 0 auto; padding: 20px; }
                        .formatter-header { margin-bottom: 20px; }
                        .formatter-main { display: flex; gap: 20px; margin-bottom: 20px; }
                        .formatter-input-section, .formatter-output-section { flex: 1; display: flex; flex-direction: column; }
                        .formatter-controls { margin-top: 10px; display: flex; gap: 10px; align-items: center; }
                        textarea { width: 100%; min-height: 300px; padding: 10px; font-family: monospace; margin-bottom: 10px; border: 1px solid #ccc; border-radius: 4px; box-sizing: border-box; }
                        button { padding: 8px 16px; background-color: #4CAF50; color: white; border: none; border-radius: 4px; cursor: pointer; }
                        button:hover { background-color: #45a049; }
                        #copy-button { align-self: flex-start; }
                        .formatter-preview-section { border: 1px solid #ddd; padding: 20px; border-radius: 4px; }
                        .preview-content { padding: 20px; background-color: #f9f9f9; border-radius: 4px; min-height: 100px; }
                        .preview-content pre { white-space: pre-wrap; word-wrap: break-word; font-family: monospace; margin: 0; }
                        /* Toggle Switch Styles */
                        .toggle-switch { position: relative; display: inline-block; }
                        .toggle-switch .toggle-label { margin-left: 50px; vertical-align: middle; }
                        .toggle-switch input { opacity: 0; width: 0; height: 0; }
                        .toggle-switch label::before { content: ""; position: absolute; left: 0; top: 50%; transform: translateY(-50%); width: 44px; height: 24px; background-color: #ccc; border-radius: 12px; transition: background-color 0.2s; cursor: pointer; }
                        .toggle-switch label::after { content: ""; position: absolute; left: 2px; top: 50%; transform: translateY(-50%); width: 20px; height: 20px; background-color: white; border-radius: 50%; transition: transform 0.2s; cursor: pointer; }
                        .toggle-switch input:checked + label::before { background-color: #4CAF50; }
                        .toggle-switch input:checked + label::after { transform: translate(20px, -50%); }
                        /* Modal styles */
                        .modal { display: none; position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.5); }
                        .modal-content { background-color: white; margin: 10% auto; padding: 20px; width: 50%; border-radius: 5px; box-shadow: 0 4px 8px rgba(0,0,0,0.2); }
                        .modal-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; }
                        .close-modal { font-size: 24px; cursor: pointer; }
                        .modal-body, .modal-footer { margin-bottom: 15px; }
                        .modal-footer { display: flex; justify-content: flex-end; }
                        .form-group { margin-bottom: 15px; }
                        .form-group label { display: block; margin-bottom: 5px; }
                        .form-group input, .form-group select { width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; box-sizing: border-box; }
                        /* Entity highlight styles */
                        .entity-reference { font-weight: bold; cursor: pointer; text-decoration: underline; }
                        .entity-character { color: #0066cc; } .entity-location { color: #008800; }
                        .entity-class { color: #990000; } .entity-subclass { color: #cc6600; }
                        .entity-guild { color: #6600cc; } .entity-item { color: #cc0099; }
                        .entity-race { color: #006666; } .entity-npc { color: #8B4513; }
                        /* Image styles */
                        .story-image-container { margin: 20px 0; }
                        .story-image-container img { max-width: 100%; height: auto; display: block; }
                        .image-caption { margin-top: 5px; font-style: italic; color: #666; }
                        .image-align-left { text-align: left; }
                        .image-align-center { text-align: center; margin-left: auto; margin-right: auto; }
                        .image-align-right { text-align: right; }
                        .story-image-container.image-align-left img, .story-image-container.image-align-right img { display: inline-block; }
                    `;
					document.head.appendChild(styleElement);
				}

				handleToggleChange() {
					this.outputAsHtml = this.htmlToggle.checked;
					const outputLabel = document.querySelector('.formatter-output-section h3');
					const originalCopyText = this.copyButton.textContent;

					if (this.outputAsHtml) {
						outputLabel.textContent = 'Formatted HTML';
						if (!originalCopyText.includes('Copied')) this.copyButton.textContent = 'Copy HTML';
					} else {
						outputLabel.textContent = 'Formatted Text (Raw)';
						if (!originalCopyText.includes('Copied')) this.copyButton.textContent = 'Copy Text';
					}
					if (this.inputElement.value.trim()) {
						this.formatText();
					}
				}

				formatText() {
					const inputText = this.inputElement.value;
					if (!inputText.trim()) {
						alert('Please enter some text to format.');
						return;
					}

					let formattedText;
					if (this.outputAsHtml) {
						formattedText = this.generateHtml(inputText);
						this.updatePreview(formattedText);
					} else {
						formattedText = this.generateRawText(inputText);
						const previewContent = formattedText.replace(/</g, '&lt;').replace(/>/g, '&gt;');
						this.updatePreview(`<pre>${previewContent}</pre>`);
					}

					this.outputElement.value = formattedText;
				}

				generateRawText(text) {
					return this.detectAndTagEntities(text);
				}

				generateHtml(text) {
					const normalizedText = text.replace(/\r\n/g, '\n');
					const lines = normalizedText.split('\n');

					const formattedLines = lines.map((line) => {
						if (!line.trim()) return ''; // Preserve empty lines as paragraph breaks

						// Skip processing for HTML header elements h2, h3, h4
						const trimmed = line.trim();
						if (/^<h(2|3|4)(\s|>)/i.test(trimmed)) {
							return trimmed; // return as-is, no tagging or paragraph wrapping
						}

						if (trimmed.startsWith('[IMAGE:')) {
							return this.convertImageTagToHtml(line);
						}

						const taggedLine = this.detectAndTagEntities(line);
						const htmlLine = this.convertTagsToHtml(taggedLine);
						return `<p>${htmlLine}</p>`;
					});

					// Join paragraphs, ensuring not to create excessive space from blank lines
					return formattedLines.join('\n').replace(/(\n<p><\/p>)+/g, '\n');
				}

				detectAndTagEntities(text) {
					let processed = text;
					for (const [type, entityList] of Object.entries(this.entities)) {
						if (!entityList.length) continue;
						const sortedEntities = [...entityList].sort((a, b) => b.length - a.length);

						for (const entityName of sortedEntities) {
							const regex = new RegExp(`\\b${this.escapeRegExp(entityName)}\\b(?![^\\[]*\\])(?![^<]*>)`, 'g');
							processed = processed.replace(regex, `[ENTITY:${type}:${entityName}]`);
						}
					}
					return processed;
				}

				convertTagsToHtml(text) {
					return text.replace(/\[ENTITY:(\w+):([^\]]+)\]/g, (match, type, name) => {
						return this.createEntitySpan(type, name);
					});
				}

				convertImageTagToHtml(tag) {
					const parts = tag.slice(7, -1).split(':');
					const src = parts[0] || '';
					const caption = parts[1] || '';
					const width = parts[2] || 'auto';
					const alignment = parts[3] || 'center';

					if (!src) return '';

					let style = width !== 'auto' ? `style="max-width: ${width};"` : '';
					const captionHtml = caption ? `<div class="image-caption">${caption}</div>` : '';

					return `
<div class="story-image-container image-align-${alignment}">
    <img src="${src}" alt="${caption || 'Story Image'}" ${style}>
    ${captionHtml}
</div>`;
				}

				createEntitySpan(type, name) {
					const cleanName = name.replace(/\\'/g, "'");
					return `<span class="entity-reference entity-${type}" data-entity-type="${type}" data-entity-name="${cleanName}">${cleanName}</span>`;
				}

				escapeRegExp(string) {
					return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
				}

				updatePreview(html) {
					this.previewElement.innerHTML = html;
				}

				copyToClipboard() {
					this.outputElement.select();
					document.execCommand('copy');
					const originalText = this.copyButton.textContent;
					this.copyButton.textContent = 'Copied!';
					setTimeout(() => {
						this.copyButton.textContent = this.outputAsHtml ? 'Copy HTML' : 'Copy Text';
					}, 2000);
				}

				// --- MODAL AND ENTITY INSERTION METHODS (Unchanged) ---

				showEntityModal() {
					let modal = document.getElementById('entity-modal');
					if (!modal) {
						modal = document.createElement('div');
						modal.id = 'entity-modal';
						modal.className = 'modal';
						const entityTypeOptions = Object.keys(this.entities)
							.map((type) => `<option value="${type}">${type.charAt(0).toUpperCase() + type.slice(1)}</option>`)
							.join('');
						modal.innerHTML = `
                            <div class="modal-content">
                                <div class="modal-header"><h3>Add Entity Reference</h3><span class="close-modal">&times;</span></div>
                                <div class="modal-body">
                                    <div class="form-group"><label for="entity-type">Entity Type:</label><select id="entity-type">${entityTypeOptions}</select></div>
                                    <div class="form-group"><label for="entity-name">Entity Name:</label><input type="text" id="entity-name" placeholder="Enter entity name"></div>
                                    <div class="form-group"><label for="existing-entities">Existing Entities:</label><select id="existing-entities"><option value="">Select an entity</option></select></div>
                                </div>
                                <div class="modal-footer"><button id="insert-entity">Insert Entity</button></div>
                            </div>`;
						document.body.appendChild(modal);
						modal.querySelector('.close-modal').addEventListener('click', () => {
							modal.style.display = 'none';
						});
						modal.querySelector('#insert-entity').addEventListener('click', () => {
							this.insertEntity();
							modal.style.display = 'none';
						});
						modal.querySelector('#entity-type').addEventListener('change', () => this.updateExistingEntitiesDropdown());
						modal.querySelector('#existing-entities').addEventListener('change', (e) => {
							if (e.target.value) document.getElementById('entity-name').value = e.target.value;
						});
					}
					setTimeout(() => this.updateExistingEntitiesDropdown(), 0);
					modal.style.display = 'block';
				}

				updateExistingEntitiesDropdown() {
					const entityType = document.getElementById('entity-type').value;
					const existingEntitiesSelect = document.getElementById('existing-entities');
					existingEntitiesSelect.innerHTML = '<option value="">Select an entity</option>';
					if (this.entities[entityType] && this.entities[entityType].length > 0) {
						this.entities[entityType].forEach((entityName) => {
							const option = document.createElement('option');
							option.value = entityName;
							option.textContent = entityName;
							existingEntitiesSelect.appendChild(option);
						});
					}
				}

				insertEntity() {
					const entityType = document.getElementById('entity-type').value;
					const entityName = document.getElementById('entity-name').value.trim();
					if (!entityType || !entityName) {
						alert('Both entity type and name are required.');
						return;
					}
					const entityTag = `[ENTITY:${entityType}:${entityName}]`;
					const cursorPos = this.inputElement.selectionStart;
					const textBefore = this.inputElement.value.substring(0, cursorPos);
					const textAfter = this.inputElement.value.substring(cursorPos);
					if (!this.entityMaps[entityType]?.has(entityName.toLowerCase())) {
						if (!this.entities[entityType]) {
							this.entities[entityType] = [];
							this.entityMaps[entityType] = new Map();
						}
						this.entities[entityType].push(entityName);
						this.entityMaps[entityType].set(entityName.toLowerCase(), entityName);
					}
					this.inputElement.value = textBefore + entityTag + textAfter;
					this.inputElement.focus();
					this.inputElement.selectionStart = cursorPos + entityTag.length;
					this.inputElement.selectionEnd = cursorPos + entityTag.length;
				}

				showImageModal() {
					let modal = document.getElementById('image-modal');
					if (!modal) {
						modal = document.createElement('div');
						modal.id = 'image-modal';
						modal.className = 'modal';
						modal.innerHTML = `
                            <div class="modal-content">
                                <div class="modal-header"><h3>Add Image</h3><span class="close-modal">&times;</span></div>
                                <div class="modal-body">
                                    <div class="form-group"><label for="image-src">Image Source:</label><input type="text" id="image-src" placeholder="path/to/image.jpg"></div>
                                    <div class="form-group"><label for="image-caption">Caption (optional):</label><input type="text" id="image-caption" placeholder="Caption for the image"></div>
                                    <div class="form-group"><label for="image-width">Width (optional):</label><input type="text" id="image-width" placeholder="e.g., 600px or 50%"></div>
                                    <div class="form-group"><label for="image-alignment">Alignment:</label><select id="image-alignment"><option value="center">Center</option><option value="left">Left</option><option value="right">Right</option></select></div>
                                </div>
                                <div class="modal-footer"><button id="insert-image">Insert Image</button></div>
                            </div>`;
						document.body.appendChild(modal);
						modal.querySelector('.close-modal').addEventListener('click', () => {
							modal.style.display = 'none';
						});
						modal.querySelector('#insert-image').addEventListener('click', () => {
							this.insertImage();
							modal.style.display = 'none';
						});
					}
					modal.style.display = 'block';
				}

				insertImage() {
					const src = document.getElementById('image-src').value.trim();
					if (!src) {
						alert('Image source is required.');
						return;
					}
					const caption = document.getElementById('image-caption').value.trim();
					const width = document.getElementById('image-width').value.trim();
					const alignment = document.getElementById('image-alignment').value;
					let imageTag = `[IMAGE:${src}`;
					if (caption) imageTag += `:${caption}`;
					if (width) imageTag += `:${width}`;
					if (alignment) imageTag += `:${alignment}`;
					imageTag += ']';

					const cursorPos = this.inputElement.selectionStart;
					const textBefore = this.inputElement.value.substring(0, cursorPos);
					const textAfter = this.inputElement.value.substring(cursorPos);
					const insertText =
						(textBefore.endsWith('\n\n') || textBefore.length === 0 ? '' : '\n\n') +
						imageTag +
						(textAfter.startsWith('\n\n') ? '' : '\n\n');
					this.inputElement.value = textBefore + insertText + textAfter;
					this.inputElement.focus();
					this.inputElement.selectionStart = this.inputElement.selectionEnd = cursorPos + insertText.length;
				}
			}

			// Initialize the formatter with entities from campaign_002_api_data.js
			const formatter = new RecapFormatter({
				characters: ['Bonnie', 'Kaedin', 'Soshi', 'Norr', 'Olek'],
				locations: [
					"Drellin's Ferry",
					'Feywilds',
					'Underdark',
					'Brindol',
					'Luskan',
					'Witchwood',
					'Green Apple Inn',
					'Shrine of Pelor',
					"Sertieren's Manor",
					'Wrath Keep',
					'Ramashen',
					"Avarthel's Grove",
					'Temple',
					'Bridge',
					'Lake',
					'Stone Ring',
					'Reptilian Path',
					'Cavern of Horrors',
					'Old Fort North of the Woods',
					'Underwater Passage',
					'Pirate Ship',
					'Mountain Waterfall',
					"Leviathan's Hall",
					'Pelagos',
					'Lustria',
					'Penal Colony',
					'Town Market',
					'General Store',
					"Armorer's Forge",
					'Ruined Fortress',
					"Mountains near Drellin's Ferry",
				],
				classes: ['Paladin', 'Sorcerer', 'Rogue', 'Fighter', 'Druid', 'Assassin', 'Trickster', 'Wizard'],
				subclasses: ['Echo Knight'],
				guilds: [
					'Arcane Brotherhood',
					'The Arcane Brotherhood',
					'Winter Rose',
					'The Winter Rose',
					"Thieves' Guild",
					'Thieves Guild',
					'Harpers',
					'The Harpers',
					'House Corzina',
					'Arcane Seekers',
					'Krynn Dynasty',
				],
				items: [],
				races: ['Earth Genasi'],
				npc: [
					'Zella',
					'Thalos',
					'Clyde',
					'Jacques',
					'Wyrmlord Koth',
					'Soranna',
					'Sergeant Hersk',
					'Brother Denny',
					'Sertieren',
					'Nels Huto',
					'Rilon Paln',
					'Anya',
					'Lem',
					'Kat',
					'Yoghurt',
					'Avarthel',
					'Loic',
					'Vandal',
					'Summoner',
					'June Takahashi',
					'Jareth',
					'Zaya',
					'Jaret',
					'Noro',
					'Palo',
					'Captain Bianca Turiados',
					'Commander Turiados',
					'Glass',
					'Marise Curs',
					'General Ilie',
					'Bardin Cratcho',
					'Scoundrel',
					'Gică',
					'Mișu',
					'Tharma',
					'Kalistra',
				],
			});
			formatter.init('formatter-container');
		</script>
	</body>
</html>
